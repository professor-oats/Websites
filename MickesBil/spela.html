<html lang="sv">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="description" content="Non-profit marketing platform to connect buyers with sellers">
  <meta name="keywords" content="marketing, non-profit, outlet, sales">
  <meta name="author" content="professor_oats">
  <meta name="viewport" content="width=device-width, intial-scale=1.0">
  <meta name="robots" content="index, follow">
  <link rel="stylesheet" type="text/css" href="styles.css">		<!-- in hosting environments this must be preceeded with '/' sometimes -->
</head>
<body>
  <section class="head-sec">
    <header id="header">
	  <h1 id="mainhead">Outletnorth*se</h1>
      <nav id="nav-bar">
        <a class="nav-link inaktivflik" href="#homepage" id="startsida">Startsida</a>
        <a class="nav-link inaktivflik" href="#ads" id="annonser">Annonser</a>
        <a class="nav-link inaktivflik" href="#hots" id="hett" >Hett Just Nu</a>
        <a class="nav-link inaktivflik" href="#contact" id="kontakt">Kontakt</a>
		<a class="nav-link aktivflik" href="#game" id="spela">Spela</a>
		<a class="nav-link inaktivflik" href="#planet" id="planet">Planet Of The Day</a>
  </section>
  <section id="wrapper" class="kommer-snart">
    <h1 class="center rubrikblock">Pac-Man</h1>
<div>
        <canvas id="gameCanvas"></canvas>
        <p class="center" id="replay">Press 'Space' to play again</p>
    </div>
    <script id="GameLoop">

        const MovingDirection = {    /* const declaration is relatively new */
            up: 0,
            down: 1,
            left: 2,
            right: 3
        }

       /*
        class MovingDirection {    /* alternative getter usage for declaring constants
            static get up() {
                return 0;
            }
            static get down() {
                return 1;
            }
            static get left() {
                return 2;
            }
            static get right() {
                return 3;
            }
        }
        */

        class Enemy {
            constructor(x, y, tileSize, velocity, tileMap) {
                this.x = x;
                this.y = y;
                this.tileSize = tileSize;
                this.velocity = velocity;
                this.tileMap = tileMap;

                this.#loadImages();

                this.movingDirection = Math.floor(    /* Make random directions for the ghosts */
                    Math.random() * Object.keys(MovingDirection).length
                );

                this.directionTimerDefault = this.#random(10, 25);
                this.directionTimer = this.directionTimerDefault;

                this.scaredAboutToExpireTimerDefault = 10;
                this.scaredAboutToExpireTimer = this.scaredAboutToExpireTimerDefault;
            }


            draw(ctx, pause, pacman) {
                if (!pause) {    /* Having game paused before first keypress of player */
                    this.#move();
                    this.#changeDirection();
                }
                this.#setImage(ctx, pacman);    /* Will set different images depending on the states of pacman power and so */
            }

            collideWith(pacman) {
                const size = this.tileSize / 2;    /* This will make it so collision happens when half way through pacman and not whole body */
                if (
                    this.x < pacman.x + size &&
                    this.x + size > pacman.x &&
                    this.y < pacman.y + size &&
                    this.y + size > pacman.y
                ) {
                    return true;
                }
                return false;
            }

            #setImage(ctx, pacman) {
                if (pacman.powerDotActive) {
                    this.#setImageWhenPowerDotIsActive(pacman);
                }
                else {
                    this.image = this.normalGhost;
                }

                ctx.drawImage(this.image, this.x, this.y, this.tileSize, this.tileSize);
            }

            #setImageWhenPowerDotIsActive(pacman) {
                if (pacman.powerDotAboutToExpire) {
                    this.scaredAboutToExpireTimer--;
                    if (this.scaredAboutToExpireTimer === 0) {
                        this.scaredAboutToExpireTimer = this.scaredAboutToExpireTimerDefault;
                        if (this.image === this.scaredGhost) {
                            this.image = this.scaredGhost2;
                        }
                        else {
                            this.image = this.scaredGhost;
                        }
                    }
                }
                else {
                    this.image = this.scaredGhost;
                }
            }

            #changeDirection() {
                this.directionTimer--;
                let newMoveDirection = null;
                if (this.directionTimer == 0) {
                    this.directionTimer = this.directionTimerDefault;
                    newMoveDirection = Math.floor(
                        Math.random() * Object.keys(MovingDirection).length
                    );
                }

                if (newMoveDirection != null && this.movingDirection != newMoveDirection) {    /* Prevents
                    the repeated same outcome of newMoveDirections so the enemies won't get stuck */
                    if (Number.isInteger(this.x / this.tileSize) &&
                        Number.isInteger(this.y / this.tileSize)) {
                        if (
                            !this.tileMap.didCollideWithEnvironment(
                                this.x,
                                this.y,
                                newMoveDirection
                            )
                        ) {

                            this.movingDirection = newMoveDirection;

                        }
                    }
                }
            }

            #move() {
                if (
                    !this.tileMap.didCollideWithEnvironment(
                        this.x,
                        this.y,
                        this.movingDirection
                    )
                ) {
                    switch (this.movingDirection) {
                        case MovingDirection.up:
                            this.y -= this.velocity;
                            break;
                        case MovingDirection.down:
                            this.y += this.velocity;
                            break;
                        case MovingDirection.left:
                            this.x -= this.velocity;
                            break;
                        case MovingDirection.right:
                            this.x += this.velocity;
                            break;
                    }
                }
            }

            #random(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            #loadImages() {
                this.normalGhost = new Image();
                this.normalGhost.src = './images/ghost.png'

                this.scaredGhost = new Image(); 
                this.scaredGhost.src = './images/scaredGhost.png'

                this.scaredGhost2 = new Image();
                this.scaredGhost2.src = './images/scaredGhost2.png'

                this.image = this.normalGhost;
            }
        }

        class PacMan {
            constructor(x, y, tileSize, velocity, tileMap) {    /* Take in what will be used when constructing */
                this.x = x;
                this.y = y;
                this.tileSize = tileSize;
                this.velocity = velocity;
                this.tileMap = tileMap;

                this.currentMovingDirection = null;
                this.requestedMovingDirection = null;

                this.pacmanAnimationTimerDefault = 10;
                this.pacmanAnimationTImer = null;

                this.pacmanRotation = this.Rotation.right;
                this.wakaSound = new Audio('./sounds/waka.wav');

                this.powerDotSound = new Audio('./sounds/power_dot.wav');
                this.powerDotActive = false;
                this.powerDotAboutToExpire = false;
                this.timers = [];

                this.eatGhostSound = new Audio('./sounds/eat_ghost.wav');

                this.madeFirstMove = false;
                this.pacmanReset = false;

                document.addEventListener("keydown", this.#keydown);

                this.#loadPacmanImages();
            }

            Rotation = {
                right: 0,
                down: 1,
                left: 2,
                up: 3
            }

            draw(ctx, pause, enemies) {

                if (!pause) {
                    this.#move();
                    this.#animate();
                }

                this.#eatDot();
                this.#eatPowerDot();
                this.#eatGhost(enemies);

                const size = this.tileSize / 2;

                /* Following ctx methods does it so we rotate displayed images so we draw Pac-Man in his
                new rotation. Then we restore it to the state it was before the translations. This is a neat way
                of reusing the images we have without having multitudes */

                ctx.save();
                ctx.translate(this.x + size, this.y + size);
                ctx.rotate((this.pacmanRotation * 90 * Math.PI) / 180);
                ctx.drawImage(this.pacmanImages[this.pacmanImageIndex], -size, -size, this.tileSize, this.tileSize);

                ctx.restore();

                /*
                ctx.drawImage(
                    this.pacmanImages[this.pacmanImageIndex],
                    this.x,
                    this.y,
                    this.tileSize,
                    this.tileSize
                );
                */
            }

            #loadPacmanImages() {
                const pacmanImage1 = new Image();
                pacmanImage1.src = './images/pac0.png';

                const pacmanImage2 = new Image();
                pacmanImage2.src = './images/pac1.png';

                const pacmanImage3 = new Image();
                pacmanImage3.src = './images/pac2.png';

                const pacmanImage4 = new Image();
                pacmanImage4.src = './images/pac1.png';

                this.pacmanImages = [
                    pacmanImage1,
                    pacmanImage2,
                    pacmanImage3,
                    pacmanImage4
                ];

                this.pacmanImageIndex = 0;
            }

            #keydown = (event) => {    /* Using an arrow function here makes it so this. is herited through
                the PacMan class instead of having its own this when checking current and requested moving direction */

                /* Mozilla Dev:
                Arrow functions don't have their own bindings to this, arguments, or super, and should not be used as methods.
                */

                //up
                if (event.keyCode == 38) {
                    if (this.currentMovingDirection == MovingDirection.down) {
                        this.currentMovingDirection = MovingDirection.up;
                    }
                    this.requestedMovingDirection = MovingDirection.up;
                    this.madeFirstMove = true;

                }
                //down
                if (event.keyCode == 40) {
                    if (this.currentMovingDirection == MovingDirection.up) {
                        this.currentMovingDirection = MovingDirection.down;
                    }
                    this.requestedMovingDirection = MovingDirection.down;
                    this.madeFirstMove = true;

                }
                //left
                if (event.keyCode == 37) {
                    if (this.currentMovingDirection == MovingDirection.right) {
                        this.currentMovingDirection = MovingDirection.left;
                    }
                    this.requestedMovingDirection = MovingDirection.left;
                    this.madeFirstMove = true;

                }
                //right
                if (event.keyCode == 39) {
                    if (this.currentMovingDirection == MovingDirection.left) {
                        this.currentMovingDirection = MovingDirection.right;
                    }
                    this.requestedMovingDirection = MovingDirection.right;
                    this.madeFirstMove = true;

                }

                if (event.keyCode == 32) {
                    this.pacmanReset = true;
                }

            }

            #move() {
                if (this.currentMovingDirection !== this.requestedMovingDirection) {
                    if (Number.isInteger(this.x / this.tileSize) &&
                        Number.isInteger(this.y / this.tileSize)) {
                        if (
                            !this.tileMap.didCollideWithEnvironment(
                                this.x,
                                this.y,
                                this.requestedMovingDirection
                            )
                        ) {
                            this.currentMovingDirection = this.requestedMovingDirection;
                        }
                    }
                }

                if (
                    this.tileMap.didCollideWithEnvironment(
                        this.x,
                        this.y,
                        this.currentMovingDirection
                    )
                ) {
                    this.pacmanAnimationTimer = null;
                    this.pacmanImageIndex = 1;    /* The image to display when Pac-Man collides */
                    return;
                }

                else if (
                    this.currentMovingDirection != null &&
                    this.pacmanAnimationTimer == null
                ) {
                    this.pacmanAnimationTimer = this.pacmanAnimationTimerDefault;
                }

                switch (this.currentMovingDirection) {
                    case MovingDirection.up:
                        this.y -= this.velocity;   /* "up" in browser is negative since y coordinate increments downwards */
                        this.pacmanRotation = this.Rotation.up;
                        break;
                    case MovingDirection.down:
                        this.y += this.velocity;
                        this.pacmanRotation = this.Rotation.down;
                        break;
                    case MovingDirection.left:
                        this.x -= this.velocity;
                        this.pacmanRotation = this.Rotation.left;
                        break;
                    case MovingDirection.right:
                        this.x += this.velocity;
                        this.pacmanRotation = this.Rotation.right;
                        break;
                }

            }

            #animate() {
                if (this.pacmanAnimationTimer == null) {
                    return;  /* Do nothing */
                }
                this.pacmanAnimationTimer--;
                if (this.pacmanAnimationTimer == 0) {
                    this.pacmanAnimationTimer = this.pacmanAnimationTimerDefault;
                    this.pacmanImageIndex++;
                    if (this.pacmanImageIndex == this.pacmanImages.length) {
                        this.pacmanImageIndex = 0;
                    }
                }

            }

            #eatDot() {
                if (this.tileMap.eatDot(this.x, this.y) && this.madeFirstMove) {
                    this.wakaSound.play();    //play sound
                }
            }

            #eatPowerDot() {
                if (this.tileMap.eatPowerDot(this.x, this.y)) {
                    this.powerDotSound.play();
                    //the ghost will become blue
                    this.powerDotActive = true;
                    this.powerDotAboutToExpire = false;
                    this.timers.forEach((timer) => clearTimeout(timer));    /* Clear the timers */
                    this.timers = [];

                    let powerDotTimer = setTimeout(() => {
                        this.powerDotActive = false;
                        this.powerDotAboutToExpire = false;
                    }, 1000 * 6);

                    this.timers.push(powerDotTimer);

                    let powerDotAboutToExpireTimer = setTimeout(() => {
                        this.powerDotAboutToExpire = true;
                    }, 1000 * 3);

                    this.timers.push(powerDotAboutToExpireTimer);
                }
            }

            #eatGhost(enemies) {
                if (this.powerDotActive) {
                    const collideEnemies = enemies.filter((enemy) => enemy.collideWith(this));    /* Find/Filter the enemy
                    that collides with Pac-Man */
                    collideEnemies.forEach((enemy) => {
                        enemies.splice(enemies.indexOf(enemy), 1);
                        this.eatGhostSound.play();
                /* Splice the filtered enemy from the array */
                    });
                }
            }
        }

        class TileMap {
            constructor(tileSize) {
                this.tileSize = tileSize;

                this.yellowDot = new Image();
                this.yellowDot.src = './images/yellowDot.png';

                this.pinkDot = new Image();
                this.pinkDot.src = './images/pinkDot.png';

                this.wall = new Image();
                this.wall.src = './images/wall.png';

                this.powerDot = this.pinkDot;
                this.powerDotAnimationTimerDefault = 30;
                this.powerDotAnimationTimer = this.powerDotAnimationTimerDefault;

            }

            /* 1 - wall
                0 - dots
                4 - Pac-Man
                5 - empty space
                6 - enemy
                7 - power dot
            */

            originmap = [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 7, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 1, 6, 0, 0, 0, 0, 0, 0, 1, 6, 1],
                    [1, 6, 1, 7, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 0, 6, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                    [1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ];

            map = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 7, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 1],
                [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                [1, 0, 1, 6, 0, 0, 0, 0, 0, 0, 1, 6, 1],
                [1, 6, 1, 7, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 6, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                [1, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];

            draw(ctx) {
                /* Make a loop over the map */
                for (let row = 0; row < this.map.length; row++) {
                    for (let column = 0; column < this.map[row].length; column++) {
                        /* get tile, each cell in array is a tile */
                        let tile = this.map[row][column];
                        if (tile === 1) {
                            this.#drawWall(ctx, column, row, this.tileSize);
                        }
                        else if (tile === 0) {
                            this.#drawDot(ctx, column, row, this.tileSize);
                        }

                        else if (tile === 7) {
                            this.#drawPowerDot(ctx, column, row, this.tileSize);
                        }

                        else {
                            this.#drawBlank(ctx, column, row, this.tileSize);
                        }

                        /* Uncomment to show map grid */
                        /*
                        ctx.strokeStyle = "yellow";
                        ctx.strokeRect(
                            column * this.tileSize,
                            row * this.tileSize,
                            this.tileSize,
                            this.tileSize
                        );
                        */
                    }
                }

            }

            #drawPowerDot(ctx, column, row, size) {
                this.powerDotAnimationTimer--;
                if (this.powerDotAnimationTimer === 0) {
                    this.powerDotAnimationTimer = this.powerDotAnimationTimerDefault;
                    if (this.powerDot == this.pinkDot) {
                        this.powerDot = this.yellowDot;
                    }
                    else {
                        this.powerDot = this.pinkDot;
                    }
                }
                ctx.drawImage(
                    this.powerDot,
                    column * size,
                    row * size,
                    size,
                    size
                );
            }

            #drawDot(ctx, column, row, size) {
                ctx.drawImage(
                    this.yellowDot,
                    column * this.tileSize,
                    row * this.tileSize,
                    size,
                    size
                );
            }

            #drawWall(ctx, column, row, size) {
                ctx.drawImage(
                    this.wall,
                    column * this.tileSize,
                    row * this.tileSize,
                    size,
                    size
                );
            }

            #drawBlank(ctx, column, row, size) {
                ctx.fillStyle = 'black';
                ctx.fillRect(column * this.tileSize, row * this.tileSize, size, size);
            }

            setCanvasSize(canvas) {
                canvas.width = this.map[0].length * this.tileSize;
                canvas.height = this.map.length * this.tileSize;
            }

            getPacMan(velocity) {
                for (let row = 0; row < this.map.length; row++) {
                    for (let column = 0; column < this.map[row].length; column++) {
                        let tile = this.map[row][column];
                        if (tile === 4) {
                            this.map[row][column] = 0;
                            return new PacMan(
                                column * this.tileSize,
                                row * this.tileSize,
                                this.tileSize,
                                velocity,
                                this
                            );
                        }
                    }
                }
            }

            getEnemies(velocity) {
                const enemies = [];

                for (let row = 0; row < this.map.length; row++) {
                    for (let column = 0; column < this.map[row].length; column++) {
                        const tile = this.map[row][column];
                        if (tile == 6) {
                            this.map[row][column] = 0;    /* 0 to keep dot behind enemies when spawning */
                            enemies.push(
                                new Enemy(
                                    column * this.tileSize,
                                    row * this.tileSize,
                                    this.tileSize,
                                    velocity,
                                    this
                                )
                            );
                        }
                    }
                }

                return enemies;
            }

            didCollideWithEnvironment(x, y, direction) {

                if (direction == null) {
                    return;
                }

                if (
                    Number.isInteger(x / this.tileSize) &&        /* This checks if Paccy is inside our block in the tilemap - between thought lines */
                    Number.isInteger(y / this.tileSize)
                ) {
                    let column = 0;
                    let row = 0;
                    let nextColumn = 0;
                    let nextRow = 0;

                    switch (direction) {
                        case MovingDirection.right:
                            nextColumn = x + this.tileSize
                            column = nextColumn / this.tileSize;
                            row = y / this.tileSize;
                            break;

                        case MovingDirection.left:
                            nextColumn = x - this.tileSize
                            column = nextColumn / this.tileSize;
                            row = y / this.tileSize;
                            break;

                        case MovingDirection.up:
                            nextRow = y - this.tileSize;
                            row = nextRow / this.tileSize;
                            column = x / this.tileSize;
                            break;

                        case MovingDirection.down:
                            nextRow = y + this.tileSize;
                            row = nextRow / this.tileSize;
                            column = x / this.tileSize;
                            break;
                          
                    }

                    const tile = this.map[row][column];
                    if (tile === 1) {
                        return true;
                    }

                }

                return false;       /* No collision */
            }

            didWin() {
                return this.#dotsLeft() === 0;
            }

            #dotsLeft() {
                return this.map.flat().filter((tile) => tile === 0).length;    /* Flat array first to make filter easy */
            }

            eatDot(x, y) {
                const row = y / this.tileSize;
                const column = x / this.tileSize;
                if (Number.isInteger(row) && Number.isInteger(column)) {    /* Use Number.isInteger to determine
                    if we do whole steps inside our grid/tilemap when either checking collisions or positions.
                    In this case we want to have a whole position of dot to be under PacMan to have him eat it. */
                    if (this.map[row][column] === 0) {    /* If PacMan finds a dot make tile into 5 (empty space) */
                        this.map[row][column] = 5;
                        return true;
                    }
                }

                return false;    /* Nothing to eat => no sound */
            }

            eatPowerDot(x, y) {
                const row = y / this.tileSize;
                const column = x / this.tileSize;
                if (Number.isInteger(row) && Number.isInteger(column)) {
                    const tile = this.map[row][column];
                    if (tile === 7) {
                        this.map[row][column] = 5;    /* Set to empty space when eaten */
                        return true;    /* Has eaten */
                    }
                }
                return false;
            }

        }

        const tileSize = 32;
        const velocity = 2;    /* Will move one step each time the game loop updates */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileMap = new TileMap(tileSize);
        let pacman = tileMap.getPacMan(velocity);
        let enemies = tileMap.getEnemies(velocity);
        /* getPacMan will return a new object of the PacMan class with the set velocity and position */

        let gameOver = false;
        let gameWin = false;
        const gameOverSound = new Audio('./sounds/gameOver.wav');
        const gameWinSound = new Audio('./sounds/gameWin.wav');

        const deepCopy = (arr) => {    /* Ty medium.com */
            let copy = [];
            arr.forEach(elem => {
                if (Array.isArray(elem)) {
                    copy.push(deepCopy(elem));
                } else {
                    if (typeof elem === 'object') {
                        copy.push(deepCopyObject(elem));
                    } else {
                        copy.push(elem);
                    }
                }
            });
            return copy;
        }

        function gameLoop() {    // most important part of our application
            tileMap.draw(ctx);
            drawGameEnd();    /* Putting draw here before the other draws is on purpose since 
            the elements are drawn cascading */
            pacman.draw(ctx, pause(), enemies);
            enemies.forEach(enemy => enemy.draw(ctx, pause(), pacman));
            checkGameOver();
            checkGameWin();
            doRestart();
        }

        function doRestart() {
            if ((gameWin || gameOver) && pacman.pacmanReset) {
                pacman.madeFirstMove = false;
                gameWin = false;
                gameOver = false;
                tileMap.map = deepCopy(tileMap.originmap);

                /* Making new objects of enemies and Pac-Man */
                enemies = tileMap.getEnemies(velocity);
                pacman = tileMap.getPacMan(velocity);

                document.getElementById("replay").style.display = "none";
            }
        }

        function checkGameWin() {
            if (!gameWin) {
                gameWin = tileMap.didWin();
                if (gameWin) {
                    gameWinSound.play();
                    pacman.pacmanReset = false;
                    document.getElementById("replay").style.display = "block";
                }
            }
        }

        function checkGameOver() {
            if (!gameOver) {
                gameOver = isGameOver();
                if (gameOver) {
                    gameOverSound.play();
                    pacman.pacmanReset = false;
                    document.getElementById("replay").style.display = "block";
                }
            }
        }

        function isGameOver() {
            /* Ask each enemy if we have collided with them */
            return enemies.some((enemy) => !pacman.powerDotActive && enemy.collideWith(pacman));
        }

        function pause() {
            return !pacman.madeFirstMove || gameOver || gameWin;
        }

        function drawGameEnd() {
            if (gameOver || gameWin) {
                let text = "  You Win!";
                if (gameOver) {
                    text = " Game Over";
                }

                ctx.fillStyle = "black";
                ctx.fillRect(0, canvas.height / 3.2, canvas.width, 80);

                ctx.font = "80px comic sans";
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                gradient.addColorStop("0", "magenta");
                gradient.addColorStop("0.5", "blue");
                gradient.addColorStop("1.0", "red");

                ctx.fillStyle = gradient;
                ctx.fillText(text, 10, canvas.height / 2);
            }
        }

        tileMap.setCanvasSize(canvas);
        setInterval(gameLoop, 1000 / 75);    // calling gameLoop 75 times every 1000 ms, redraw screen
    </script>

  </section>
</body>
</html>